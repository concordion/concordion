<?xml version="1.0" encoding="UTF-8"?><html xmlns:concordion="http://www.concordion.org/2007/concordion"><head><style>* {
  font-family: Arial;
}
body {
  padding: 32px;  
}
pre {
  padding: 6px 28px 6px 28px;
  background-color: #E8EEF7;
}
pre, pre *, code, code *, kbd {
  font-family: Courier New, Courier;
  font-size: 10pt;
}
h1, h1 * {
  font-size: 24pt;	
}
p, td, th, li, .breadcrumbs {
  font-size: 10pt;
}
p, li {
  line-height: 140%;
  max-width: 720px;
}
table {
  border-collapse: collapse;
  empty-cells: show;
  margin: 8px 0px 8px 0px;
}
th, td {
  border: 1px solid black;
  padding: 3px;
}
td {
  background-color: white;
  vertical-align: top;
}
th {
  background-color: #C3D9FF;
}
li {
  margin-top: 6px;
  margin-bottom: 6px; 
}

.example, :not(th)[concordion\:example] {
  padding: 6px 16px 6px 16px;
  border: 1px solid #C3D9FF;
  margin: 6px 0px 28px 0px;
  background-color: #F5F9FD;
}
.example h3, [concordion\:example] h3 {
  margin-top: 8px;
  margin-bottom: 8px;
  font-size: 12pt;
}

p.success {
  padding: 2px;
}
.success, .success * {
  background-color: #afa !important;
}
.success pre {
  background-color: #bbffbb;
}
.failure, .failure * {
  background-color: #ffb0b0;
  padding: 1px;
}
.failure .expected {
  text-decoration: line-through;
  color: #bb5050;
}
.ignored, .ignored * {
  background-color: #f0f0f0 !important;	
}

ins {
  text-decoration: none;	
}

.exceptionMessage {
  background-color: #fdd;
  font-family: Courier New, Courier, Monospace;
  font-size: 10pt;
  display: block;
  font-weight: normal;
  padding: 4px;
  text-decoration: none !important;
}
.stackTrace, .stackTrace * {
  font-weight: normal;
}
.stackTrace {
  display: none;
  padding: 1px 4px 4px 4px;
  background-color: #fdd;
  border-top: 1px dotted black;
}
.stackTraceExceptionMessage {
  display: block;
  font-family: Courier New, Courier, Monospace;
  font-size: 8pt;
  white-space: wrap;
  padding: 1px 0px 1px 0px;
}
.stackTraceEntry {
  white-space: nowrap;
  font-family: Courier New, Courier, Monospace;
  display: block;
  font-size: 8pt;
  padding: 1px 0px 1px 32px;
}
.stackTraceButton {
  font-size: 8pt;
  margin: 2px 8px 2px 0px;
  font-weight: normal;
  font-family: Arial;
}

.special {
  font-style: italic;
}
.missing, .missing * {
  background-color: #ff9999;
  color:#bb5050;
  text-decoration: line-through;
}
.surplus, .surplus * {
  background-color: #ff9999;
}
.footer {
  text-align: right;
  margin-top: 40px;
  font-size: 8pt;
  width: 100%;
  color: #999;
}
.footer .testTime {
  padding: 2px 10px 0px 0px;
}

.idea {
  font-size: 9pt;
  color: #888;
  font-style: italic;	
}
.tight li {
  margin-top: 1px;
  margin-bottom: 1px; 
}
.commentary {
  float: right;
  width: 200px;
  background-color: #ffffd0;
  padding:8px;
  border: 3px solid #eeeeb0;	 
  margin: 10px 0px 10px 10px;	 
}
.commentary, .commentary * {
  font-size: 8pt;
}
</style><meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<link href="../../../concordion.css" rel="stylesheet" type="text/css" />
</head><body><span class="breadcrumbs"><a href="../../../Concordion.html">Concordion</a> &gt; <a href="../Command.html">Commands</a> &gt;</span>

<h1>Expressions</h1>

<p>Concordion uses expressions to reference fields and call methods of the corresponding test fixture and to set specification variables.</p>
<p>In order to <a href="https://concordion.org/Technique.html#keepSpecsSimple">keep your specifications simple and maintainable</a>, Concordion deliberately restricts the expression format that is allowed when instrumenting specifications.
Complexity should be moved into the fixture code, and then <a href="https://concordion.org/Technique.html#evolveDSL">evolved into a DSL</a>, where it is easier to maintain. 
The idea is to have the fixture do all the work of fetching and munging the data and then return exactly the data that the spec needs, 
which helps to decouple the spec from the implementation.</p>
<p>The following expressions are available within Concordion commands:</p>

<div class="example">

    <h3>Examples</h3>

    <p>Evaluation expressions</p>
    <ol>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">myProp</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">myMethod()</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">myMethod(#var1)</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">myMethod(#var1, #var2)</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var.myProp</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var.myProp.myProp</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var = myProp</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var = myMethod()</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var = myMethod(#var1)</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var = myMethod(#var1, #var2)</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var ? 's1' : 's2'</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">myProp ? 's1' : 's2'</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">myMethod() ? 's1' : 's2'</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">myMethod(#var1) ? 's1' : 's2'</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">myMethod(#var1, #var2) ? 's1' : 's2'</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var.myProp</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var.myMethod()</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var.myMethod(#var1)</li>
        <li concordion:assertTrue="isValidEvaluationExpression(#TEXT)" class="success">#var.myMethod(#var1, #var2)</li>
    </ol>
    <p>Set expressions</p>
    <ul>
        <li concordion:assertTrue="isValidSetVariableExpression(#TEXT)" class="success">#var = myProp</li>
        <li concordion:assertTrue="isValidSetVariableExpression(#TEXT)" class="success">#var = myMethod()</li>
        <li concordion:assertTrue="isValidSetVariableExpression(#TEXT)" class="success">#var = myMethod(#var1)</li>
        <li concordion:assertTrue="isValidSetVariableExpression(#TEXT)" class="success">#var = myMethod(#var1, #var2)</li>
    </ul>
</div>

<p>However, if you really want to remove this restriction you can apply the annotation <code>@FullOGNL</code> to your fixture class to allow 
<a concordion:run="concordion" href="ComplexExpressions.html" class="success">complex expressions</a>. 
This would allow you to do things like
<a href="http://stackoverflow.com/questions/23658633/use-result-object-of-first-concordion-call-as-arg-in-secound-concordion-call">pass property values of Java beans into methods</a>
, or <a href="http://stackoverflow.com/questions/19681470/sending-a-constant-parameter-to-concoridion-execute-call">use constant values in concordion:execute commands</a>.</p>

<h2>Further Details</h2>
<ul>
    <li>The default expression syntax is too limiting. How do I use <a concordion:run="concordion" href="ComplexExpressions.html" class="success">complex expressions</a>?</li>
</ul>


<div class="footer">Results generated by <a href="http://www.concordion.org" style="font-weight: bold; text-decoration: none; color: #89C;">Concordion</a><div class="testTime">in 4908 ms on 16-July-2023 at 21:30:34 NZST</div></div></body>
</html>